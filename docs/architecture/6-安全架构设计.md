# 6. 安全架构设计

## 6.1 数据安全策略

### 6.1.1 加密存储方案

```typescript
// 数据加密管理器
export class DataEncryptionManager {
  private readonly algorithm = 'aes-256-gcm';
  private encryptionKey: Buffer;
  
  constructor() {
    this.encryptionKey = this.deriveEncryptionKey();
  }
  
  // 敏感数据加密
  async encryptSensitiveData(data: any): Promise<EncryptedData> {
    const jsonData = JSON.stringify(data);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipher(this.algorithm, this.encryptionKey);
    cipher.setAAD(Buffer.from('zcu-metadata'));
    
    let encrypted = cipher.update(jsonData, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      timestamp: Date.now()
    };
  }
  
  // 数据解密
  async decryptSensitiveData(encryptedData: EncryptedData): Promise<any> {
    const decipher = crypto.createDecipher(this.algorithm, this.encryptionKey);
    decipher.setAAD(Buffer.from('zcu-metadata'));
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }
  
  // 密钥派生
  private deriveEncryptionKey(): Buffer {
    const password = process.env.ZCU_ENCRYPTION_PASSWORD || 'zcu-default-key';
    const salt = Buffer.from('zcu-salt-2025', 'utf8');
    
    return crypto.pbkdf2Sync(password, salt, 100000, 32, 'sha256');
  }
}

// 数据脱敏处理
export class DataSanitizer {
  private sensitivePatterns = [
    /api[_-]?key/i,
    /password/i,
    /secret/i,
    /token/i,
    /auth/i,
    /credential/i
  ];
  
  // 自动脱敏
  sanitizeData(data: any): any {
    if (typeof data === 'string') {
      return this.sanitizeString(data);
    }
    
    if (Array.isArray(data)) {
      return data.map(item => this.sanitizeData(item));
    }
    
    if (typeof data === 'object' && data !== null) {
      const sanitized: any = {};
      
      for (const [key, value] of Object.entries(data)) {
        if (this.isSensitiveKey(key)) {
          sanitized[key] = '[REDACTED]';
        } else {
          sanitized[key] = this.sanitizeData(value);
        }
      }
      
      return sanitized;
    }
    
    return data;
  }
  
  private isSensitiveKey(key: string): boolean {
    return this.sensitivePatterns.some(pattern => pattern.test(key));
  }
  
  private sanitizeString(str: string): string {
    // 移除可能的敏感信息
    return str
      .replace(/sk-[a-zA-Z0-9]{48}/g, '[API_KEY_REDACTED]')
      .replace(/\b[A-Za-z0-9]{32,}\b/g, '[HASH_REDACTED]');
  }
}
```

## 6.2 操作安全控制

### 6.2.1 权限验证系统

```typescript
// 操作权限管理
export class OperationPermissionManager {
  private permissionMatrix: Map<string, PermissionRule[]> = new Map();
  
  constructor() {
    this.initializePermissionRules();
  }
  
  // 操作权限验证
  async checkOperationPermission(
    operation: Operation,
    context: OperationContext
  ): Promise<PermissionResult> {
    const rules = this.permissionMatrix.get(operation.type) || [];
    
    for (const rule of rules) {
      const result = await this.evaluateRule(rule, operation, context);
      
      if (!result.allowed) {
        return {
          allowed: false,
          reason: result.reason,
          requiredConfirmation: result.confirmation
        };
      }
    }
    
    return { allowed: true };
  }
  
  // 危险操作检测
  async detectDangerousOperation(operation: Operation): Promise<DangerAssessment> {
    const riskFactors: RiskFactor[] = [];
    
    // 检测大规模文件删除
    if (operation.type === 'delete' && operation.files.length > 10) {
      riskFactors.push({
        type: 'mass_deletion',
        severity: 'high',
        description: `将删除 ${operation.files.length} 个文件`
      });
    }
    
    // 检测系统文件操作
    const systemFiles = operation.files.filter(f => 
      f.path.includes('node_modules') || 
      f.path.includes('.git') ||
      f.path.startsWith('/')
    );
    
    if (systemFiles.length > 0) {
      riskFactors.push({
        type: 'system_file_access',
        severity: 'medium',
        description: '操作涉及系统关键文件'
      });
    }
    
    // 计算总体风险等级
    const riskLevel = this.calculateRiskLevel(riskFactors);
    
    return {
      riskLevel,
      riskFactors,
      requiresConfirmation: riskLevel >= 'medium',
      recommendedActions: this.getRecommendedActions(riskFactors)
    };
  }
  
  private initializePermissionRules(): void {
    // Undo操作权限规则
    this.permissionMatrix.set('undo', [
      {
        name: 'recent_operation_check',
        evaluator: async (op, ctx) => {
          const lastOperation = await this.getLastOperation(ctx.workspaceId);
          const timeDiff = Date.now() - lastOperation.timestamp;
          
          if (timeDiff > 3600000) { // 1小时
            return {
              allowed: false,
              reason: '操作时间过久，为安全起见需要确认',
              confirmation: 'extended_time_warning'
            };
          }
          
          return { allowed: true };
        }
      }
    ]);
    
    // 删除操作权限规则
    this.permissionMatrix.set('delete', [
      {
        name: 'file_count_limit',
        evaluator: async (op, ctx) => {
          if (op.files.length > 50) {
            return {
              allowed: false,
              reason: '单次删除文件数量过多',
              confirmation: 'mass_deletion_warning'
            };
          }
          return { allowed: true };
        }
      }
    ]);
  }
}

// 操作确认系统
export class OperationConfirmationSystem {
  // 生成确认提示
  generateConfirmationPrompt(
    operation: Operation,
    dangerAssessment: DangerAssessment
  ): ConfirmationPrompt {
    const prompt: ConfirmationPrompt = {
      title: this.getOperationTitle(operation),
      description: this.getOperationDescription(operation),
      riskLevel: dangerAssessment.riskLevel,
      warnings: dangerAssessment.riskFactors.map(factor => factor.description),
      actions: [
        {
          label: '确认执行',
          action: 'confirm',
          variant: dangerAssessment.riskLevel === 'high' ? 'danger' : 'primary'
        },
        {
          label: '取消',
          action: 'cancel',
          variant: 'secondary'
        }
      ]
    };
    
    // 高风险操作需要额外确认
    if (dangerAssessment.riskLevel === 'high') {
      prompt.requiresTypeConfirmation = true;
      prompt.typeConfirmationText = 'CONFIRM';
    }
    
    return prompt;
  }
  
  // CLI确认界面
  async showCLIConfirmation(prompt: ConfirmationPrompt): Promise<boolean> {
    console.log(chalk.yellow.bold(`⚠️  ${prompt.title}`));
    console.log(chalk.gray(prompt.description));
    
    if (prompt.warnings.length > 0) {
      console.log(chalk.red('\n风险警告:'));
      prompt.warnings.forEach(warning => {
        console.log(chalk.red(`  • ${warning}`));
      });
    }
    
    if (prompt.requiresTypeConfirmation) {
      const typeConfirmation = await inquirer.prompt([{
        type: 'input',
        name: 'confirmation',
        message: `请输入 "${prompt.typeConfirmationText}" 以确认操作:`
      }]);
      
      if (typeConfirmation.confirmation !== prompt.typeConfirmationText) {
        return false;
      }
    }
    
    const answer = await inquirer.prompt([{
      type: 'confirm',
      name: 'proceed',
      message: '确认要继续吗?',
      default: false
    }]);
    
    return answer.proceed;
  }
}
```

---
