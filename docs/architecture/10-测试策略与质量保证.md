# 10. 测试策略与质量保证

## 10.1 测试架构

### 10.1.1 测试金字塔

```typescript
// 测试配置 - vitest.config.ts
import { defineConfig } from 'vitest/config'
import path from 'node:path'

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./tests/setup.ts'],
    // Vitest 3.x 新特性：改进的并行处理
    pool: 'threads',
    poolOptions: {
      threads: {
        minThreads: 1,
        maxThreads: 4
      }
    },
    // 优化文件监听
    watch: {
      ignore: ['**/node_modules/**', '**/dist/**']
    },
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov', 'json'],
      include: ['src/**/*.ts'],
      exclude: [
        'src/**/*.test.ts',
        'src/**/*.spec.ts', 
        'src/types/**',
        'node_modules/**',
        'dist/**'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 85,
          lines: 85,
          statements: 85
        }
      },
      // Vitest 3.x: 支持增量覆盖率报告
      reportOnFailure: true,
      cleanOnRerun: true
    },
    // 新增：更好的错误报告
    outputFile: {
      junit: './reports/junit.xml',
      json: './reports/test-results.json'
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@zcu/core': path.resolve(__dirname, './packages/core/src'),
      '@zcu/shared': path.resolve(__dirname, './packages/shared/src')
    }
  }
})

// 测试设置 - tests/setup.ts
import { vi } from 'vitest'

// Mock LevelDB for tests
vi.mock('level', () => ({
  Level: vi.fn().mockImplementation(() => ({
    get: vi.fn(),
    put: vi.fn(), 
    del: vi.fn(),
    batch: vi.fn().mockReturnValue({
      put: vi.fn(),
      del: vi.fn(),
      write: vi.fn()
    }),
    iterator: vi.fn(),
    close: vi.fn()
  }))
}))

// Mock file system operations
vi.mock('node:fs/promises', async () => {
  const actual = await vi.importActual('node:fs/promises')
  return {
    ...actual,
    readFile: vi.fn(),
    writeFile: vi.fn(),
    unlink: vi.fn(),
    stat: vi.fn()
  }
})

// 全局测试工具
global.createMockWorkspace = () => ({
  id: 'test-workspace',
  sessionId: 'test-session',
  aiAgent: 'claude-test',
  projectPath: '/test/project',
  state: 'active' as const,
  operationChain: [],
  createdAt: Date.now(),
  lastActivity: Date.now()
})

global.createMockSnapshot = () => ({
  id: 'test-snapshot',
  description: 'Test snapshot',
  timestamp: Date.now(),
  filesCount: 3,
  workspaceId: 'test-workspace',
  checksum: 'test-checksum'
})
```

### 10.1.2 单元测试示例

```typescript
// packages/core/src/workspace/WorkspaceManager.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { WorkspaceManager } from './WorkspaceManager'
import type { AIWorkspace } from '../types'

describe('WorkspaceManager', () => {
  let workspaceManager: WorkspaceManager
  let mockDb: any
  
  beforeEach(() => {
    mockDb = {
      get: vi.fn(),
      put: vi.fn(),
      del: vi.fn()
    }
    workspaceManager = new WorkspaceManager(mockDb)
  })
  
  describe('createWorkspace', () => {
    it('should create a new workspace with correct properties', async () => {
      const sessionId = 'test-session-123'
      const aiAgent = 'claude-3-sonnet'
      const projectPath = '/test/project'
      
      const workspace = await workspaceManager.createWorkspace(
        sessionId,
        aiAgent,
        projectPath
      )
      
      expect(workspace).toMatchObject({
        sessionId,
        aiAgent,
        projectPath,
        state: 'active',
        operationChain: []
      })
      
      expect(workspace.id).toBeDefined()
      expect(workspace.createdAt).toBeTypeOf('number')
      expect(workspace.lastActivity).toBeTypeOf('number')
    })
    
    it('should persist workspace to database', async () => {
      const workspace = await workspaceManager.createWorkspace(
        'session',
        'claude',
        '/project'
      )
      
      expect(mockDb.put).toHaveBeenCalledWith(
        `workspace:${workspace.id}:metadata`,
        expect.objectContaining({
          id: workspace.id,
          sessionId: 'session',
          aiAgent: 'claude'
        })
      )
    })
    
    it('should handle duplicate workspace creation', async () => {
      // 模拟已存在的工作空间
      mockDb.get.mockResolvedValue({
        id: 'existing-workspace',
        sessionId: 'session',
        aiAgent: 'claude'
      })
      
      const workspace = await workspaceManager.getOrCreateWorkspace(
        'session',
        'claude', 
        '/project'
      )
      
      expect(workspace.id).toBe('existing-workspace')
      expect(mockDb.put).not.toHaveBeenCalled()
    })
  })
  
  describe('conflict detection', () => {
    it('should detect file lock conflicts', async () => {
      const workspace1 = createMockWorkspace()
      const workspace2 = { ...createMockWorkspace(), id: 'workspace-2' }
      
      // 工作空间1获取文件锁
      await workspaceManager.acquireFileLocks(workspace1.id, ['file1.ts'])
      
      // 工作空间2尝试获取相同文件锁
      const conflicts = await workspaceManager.checkConflicts(
        workspace2.id,
        ['file1.ts']
      )
      
      expect(conflicts).toHaveLength(1)
      expect(conflicts[0]).toMatchObject({
        filePath: 'file1.ts',
        sourceWorkspace: workspace2.id,
        conflictWorkspace: workspace1.id,
        type: 'file_lock_conflict'
      })
    })
    
    it('should allow non-conflicting file operations', async () => {
      const workspace1 = createMockWorkspace()
      const workspace2 = { ...createMockWorkspace(), id: 'workspace-2' }
      
      await workspaceManager.acquireFileLocks(workspace1.id, ['file1.ts'])
      
      const conflicts = await workspaceManager.checkConflicts(
        workspace2.id,
        ['file2.ts'] // 不同文件
      )
      
      expect(conflicts).toHaveLength(0)
    })
  })
})
```

### 10.1.3 集成测试

```typescript
// tests/integration/snapshot.integration.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { promises as fs } from 'node:fs'
import path from 'node:path'
import os from 'node:os'
import { SnapshotManager } from '@zcu/core/snapshot'
import { ShadowRepositoryManager } from '@zcu/core/storage'

describe('Snapshot Integration Tests', () => {
  let testDir: string
  let snapshotManager: SnapshotManager
  let shadowRepo: ShadowRepositoryManager
  
  beforeEach(async () => {
    // 创建临时测试目录
    testDir = await fs.mkdtemp(path.join(os.tmpdir(), 'zcu-integration-'))
    
    shadowRepo = new ShadowRepositoryManager(testDir)
    await shadowRepo.initialize()
    
    snapshotManager = new SnapshotManager(testDir, shadowRepo)
  })
  
  afterEach(async () => {
    // 清理测试目录
    await fs.rm(testDir, { recursive: true, force: true })
  })
  
  it('should create and restore snapshots correctly', async () => {
    // 创建测试文件
    const testFile = path.join(testDir, 'test.txt')
    const originalContent = 'original content'
    await fs.writeFile(testFile, originalContent)
    
    // 创建快照
    const snapshot = await snapshotManager.createSnapshot(
      'Initial snapshot',
      [{ path: 'test.txt', content: originalContent, operation: 'create' }]
    )
    
    expect(snapshot).toBeDefined()
    expect(snapshot.description).toBe('Initial snapshot')
    
    // 修改文件
    const modifiedContent = 'modified content'
    await fs.writeFile(testFile, modifiedContent)
    
    // 恢复快照
    await snapshotManager.restoreSnapshot(snapshot.id, testDir)
    
    // 验证文件已恢复
    const restoredContent = await fs.readFile(testFile, 'utf8')
    expect(restoredContent).toBe(originalContent)
  })
  
  it('should handle multiple file operations', async () => {
    const files = [
      { name: 'file1.txt', content: 'content 1' },
      { name: 'file2.txt', content: 'content 2' },
      { name: 'file3.txt', content: 'content 3' }
    ]
    
    // 创建多个文件
    for (const file of files) {
      await fs.writeFile(path.join(testDir, file.name), file.content)
    }
    
    // 创建快照
    const snapshot = await snapshotManager.createSnapshot(
      'Multi-file snapshot',
      files.map(f => ({
        path: f.name,
        content: f.content,
        operation: 'create' as const
      }))
    )
    
    // 删除所有文件
    for (const file of files) {
      await fs.unlink(path.join(testDir, file.name))
    }
    
    // 恢复快照
    await snapshotManager.restoreSnapshot(snapshot.id, testDir)
    
    // 验证所有文件已恢复
    for (const file of files) {
      const restoredContent = await fs.readFile(
        path.join(testDir, file.name),
        'utf8'
      )
      expect(restoredContent).toBe(file.content)
    }
  })
  
  it('should track snapshot history correctly', async () => {
    const snapshots = []
    
    // 创建多个快照
    for (let i = 1; i <= 3; i++) {
      await fs.writeFile(
        path.join(testDir, `file${i}.txt`),
        `content ${i}`
      )
      
      const snapshot = await snapshotManager.createSnapshot(
        `Snapshot ${i}`,
        [{ 
          path: `file${i}.txt`, 
          content: `content ${i}`, 
          operation: 'create' 
        }]
      )
      
      snapshots.push(snapshot)
    }
    
    // 获取快照历史
    const history = await snapshotManager.getSnapshotHistory()
    
    expect(history).toHaveLength(3)
    expect(history.map(s => s.description)).toEqual([
      'Snapshot 3', // 最新的在前
      'Snapshot 2',
      'Snapshot 1'
    ])
  })
})
```

### 10.1.4 E2E测试

```typescript
// tests/e2e/cli-workflow.e2e.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { spawn, ChildProcess } from 'node:child_process'
import { promises as fs } from 'node:fs'
import path from 'node:path'
import os from 'node:os'

describe('CLI E2E Tests', () => {
  let testProject: string
  let cliProcess: ChildProcess | null = null
  
  beforeEach(async () => {
    testProject = await fs.mkdtemp(path.join(os.tmpdir(), 'zcu-e2e-'))
    
    // 创建测试项目结构
    await fs.mkdir(path.join(testProject, 'src'))
    await fs.writeFile(
      path.join(testProject, 'src', 'index.ts'),
      'console.log("Hello ZCU")'
    )
  })
  
  afterEach(async () => {
    if (cliProcess) {
      cliProcess.kill()
      cliProcess = null
    }
    
    await fs.rm(testProject, { recursive: true, force: true })
  })
  
  const runCLICommand = (args: string[], input?: string): Promise<string> => {
    return new Promise((resolve, reject) => {
      const process = spawn('node', ['../bin/zcu.mjs', ...args], {
        cwd: testProject,
        stdio: ['pipe', 'pipe', 'pipe']
      })
      
      let output = ''
      let error = ''
      
      process.stdout.on('data', (data) => {
        output += data.toString()
      })
      
      process.stderr.on('data', (data) => {
        error += data.toString()
      })
      
      process.on('close', (code) => {
        if (code === 0) {
          resolve(output)
        } else {
          reject(new Error(`CLI exited with code ${code}: ${error}`))
        }
      })
      
      if (input) {
        process.stdin.write(input)
        process.stdin.end()
      }
    })
  }
  
  it('should initialize ZCU in project', async () => {
    const output = await runCLICommand(['init'])
    
    expect(output).toContain('ZCU initialized successfully')
    
    // 验证初始化文件存在
    const configExists = await fs.access(
      path.join(testProject, '.zcu', 'config.json')
    ).then(() => true).catch(() => false)
    
    expect(configExists).toBe(true)
  })
  
  it('should create and list snapshots', async () => {
    // 初始化
    await runCLICommand(['init'])
    
    // 创建快照
    const createOutput = await runCLICommand([
      'snapshot',
      'create',
      '--description',
      'Initial snapshot'
    ])
    
    expect(createOutput).toContain('Snapshot created successfully')
    
    // 列出快照
    const listOutput = await runCLICommand(['snapshot', 'list'])
    
    expect(listOutput).toContain('Initial snapshot')
  })
  
  it('should handle undo/redo operations', async () => {
    await runCLICommand(['init'])
    
    // 创建初始快照
    await runCLICommand(['snapshot', 'create', '-d', 'Initial'])
    
    // 修改文件
    await fs.writeFile(
      path.join(testProject, 'src', 'index.ts'),
      'console.log("Modified content")'
    )
    
    // 创建修改后快照
    await runCLICommand(['snapshot', 'create', '-d', 'Modified'])
    
    // 执行撤销
    const undoOutput = await runCLICommand(['undo'])
    
    expect(undoOutput).toContain('Undo completed successfully')
    
    // 验证文件已恢复
    const restoredContent = await fs.readFile(
      path.join(testProject, 'src', 'index.ts'),
      'utf8'
    )
    
    expect(restoredContent).toBe('console.log("Hello ZCU")')
    
    // 执行重做
    const redoOutput = await runCLICommand(['redo'])
    
    expect(redoOutput).toContain('Redo completed successfully')
    
    // 验证文件已重做
    const redoneContent = await fs.readFile(
      path.join(testProject, 'src', 'index.ts'),
      'utf8'
    )
    
    expect(redoneContent).toBe('console.log("Modified content")')
  })
  
  it('should detect and handle conflicts', async () => {
    await runCLICommand(['init'])
    
    // 模拟多工作空间冲突场景
    // 这需要更复杂的设置来模拟多个AI实例
    // 此处简化为基本冲突检测测试
    
    const output = await runCLICommand(['workspace', 'status'])
    
    expect(output).toContain('Active workspaces')
  })
})
```

## 10.2 性能测试

### 10.2.1 基准测试

```typescript
// tests/performance/benchmark.test.ts
import { describe, it, expect } from 'vitest'
import { performance } from 'node:perf_hooks'
import { SnapshotManager } from '@zcu/core/snapshot'
import { WorkspaceManager } from '@zcu/core/workspace'

describe('Performance Benchmarks', () => {
  it('should create snapshots within performance budget', async () => {
    const snapshotManager = new SnapshotManager()
    
    // 生成大量文件数据
    const files = Array.from({ length: 100 }, (_, i) => ({
      path: `test-file-${i}.ts`,
      content: `// Generated test file ${i}\n`.repeat(100),
      operation: 'create' as const
    }))
    
    const startTime = performance.now()
    
    const snapshot = await snapshotManager.createSnapshot(
      'Performance test snapshot',
      files
    )
    
    const duration = performance.now() - startTime
    
    expect(snapshot).toBeDefined()
    expect(duration).toBeLessThan(3000) // 3秒以内
  })
  
  it('should handle concurrent workspace operations efficiently', async () => {
    const workspaceManager = new WorkspaceManager()
    
    const startTime = performance.now()
    
    // 并发创建多个工作空间
    const promises = Array.from({ length: 10 }, (_, i) => 
      workspaceManager.createWorkspace(
        `session-${i}`,
        `claude-${i}`,
        `/project-${i}`
      )
    )
    
    const workspaces = await Promise.all(promises)
    
    const duration = performance.now() - startTime
    
    expect(workspaces).toHaveLength(10)
    expect(duration).toBeLessThan(1000) // 1秒以内
  })
  
  it('should maintain memory usage within limits', async () => {
    const initialMemory = process.memoryUsage().heapUsed
    
    const snapshotManager = new SnapshotManager()
    
    // 创建大量快照
    for (let i = 0; i < 50; i++) {
      await snapshotManager.createSnapshot(
        `Memory test snapshot ${i}`,
        [{
          path: `file-${i}.ts`,
          content: 'x'.repeat(10000), // 10KB per file
          operation: 'create'
        }]
      )
    }
    
    const finalMemory = process.memoryUsage().heapUsed
    const memoryIncrease = finalMemory - initialMemory
    
    // 内存增长应控制在50MB以内
    expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024)
  })
})
```

---
