# 4. 存储架构设计

## 4.1 LevelDB + Shadow Repository存储架构

### 4.1.1 分层存储设计

```typescript
// 存储层架构设计
interface StorageArchitecture {
  // 元数据层 - LevelDB
  metadata: {
    workspaces: Map<string, WorkspaceMetadata>;
    sessions: Map<string, SessionInfo>;
    operations: Map<string, OperationMetadata>;
    conflicts: Map<string, ConflictMetadata>;
  };
  
  // 文件快照层 - Shadow Repository
  snapshots: {
    repository: GitRepository;
    branches: Map<string, SnapshotBranch>;
    commits: Map<string, SnapshotCommit>;
  };
  
  // 缓存层 - Memory Cache
  cache: {
    hotSnapshots: LRUCache<Snapshot>;
    activeWorkspaces: Map<string, AIWorkspace>;
    recentOperations: CircularBuffer<Operation>;
  };
}

// LevelDB键值设计
export const LevelDBSchema = {
  // 工作空间相关
  workspace: {
    active: (aiId: string) => `workspace:${aiId}:active`,
    metadata: (id: string) => `workspace:${id}:metadata`,
    operations: (id: string) => `workspace:${id}:operations`,
    state: (id: string) => `workspace:${id}:state`
  },
  
  // 操作记录
  operation: {
    latest: (aiId: string) => `operation:${aiId}:latest`,
    history: (aiId: string) => `operation:${aiId}:history`,
    metadata: (id: string) => `operation:${id}:metadata`
  },
  
  // 冲突管理
  conflict: {
    active: (projectPath: string) => `conflict:${projectPath}:active`,
    resolved: (id: string) => `conflict:${id}:resolved`,
    pending: () => `conflict:pending`
  },
  
  // 安全相关
  safety: {
    level: (operationId: string) => `safety:${operationId}:level`,
    rollback: (id: string) => `safety:${id}:rollback`
  }
} as const;
```

### 4.1.2 Shadow Repository实现

```typescript
// Shadow Repository管理器
export class ShadowRepositoryManager {
  private shadowRepo: SimpleGit;
  private repoPath: string;
  
  constructor(projectPath: string) {
    this.repoPath = path.join(projectPath, '.zcu', 'shadow');
    this.shadowRepo = simpleGit(this.repoPath);
  }
  
  // 初始化Shadow Repository
  async initialize(): Promise<void> {
    if (!await this.exists()) {
      await fs.ensureDir(this.repoPath);
      await this.shadowRepo.init();
      await this.createInitialCommit();
    }
  }
  
  // 创建文件快照
  async createSnapshot(description: string, files: FileChange[]): Promise<string> {
    const snapshotId = generateSnapshotId();
    const branchName = `snapshot/${snapshotId}`;
    
    // 创建新分支
    await this.shadowRepo.checkoutLocalBranch(branchName);
    
    // 应用文件变更
    for (const file of files) {
      const targetPath = path.join(this.repoPath, file.relativePath);
      
      switch (file.operation) {
        case 'create':
        case 'modify':
          await fs.writeFile(targetPath, file.content);
          await this.shadowRepo.add(file.relativePath);
          break;
        case 'delete':
          await fs.remove(targetPath);
          await this.shadowRepo.rm(file.relativePath);
          break;
        case 'rename':
          await this.shadowRepo.mv(file.oldPath, file.relativePath);
          break;
      }
    }
    
    // 提交快照
    await this.shadowRepo.commit(description, {
      '--author': `"ZCU System <zcu@system>"`,
      '--date': new Date().toISOString()
    });
    
    // 返回主分支
    await this.shadowRepo.checkout('main');
    
    return snapshotId;
  }
  
  // 恢复快照
  async restoreSnapshot(snapshotId: string, targetPath: string): Promise<void> {
    const branchName = `snapshot/${snapshotId}`;
    
    // 检出快照分支
    await this.shadowRepo.checkout(branchName);
    
    // 获取快照内容
    const files = await this.getSnapshotFiles(snapshotId);
    
    // 恢复文件到目标路径
    for (const file of files) {
      const sourcePath = path.join(this.repoPath, file.relativePath);
      const targetFilePath = path.join(targetPath, file.relativePath);
      
      if (file.operation === 'delete') {
        await fs.remove(targetFilePath);
      } else {
        await fs.copy(sourcePath, targetFilePath);
      }
    }
    
    // 返回主分支
    await this.shadowRepo.checkout('main');
  }
  
  // 增量存储优化
  async createIncrementalSnapshot(
    baseSnapshotId: string,
    changes: FileChange[]
  ): Promise<string> {
    const newSnapshotId = generateSnapshotId();
    const baseBranch = `snapshot/${baseSnapshotId}`;
    const newBranch = `snapshot/${newSnapshotId}`;
    
    // 基于基础快照创建新分支
    await this.shadowRepo.checkoutBranch(newBranch, baseBranch);
    
    // 只应用增量变更
    const incrementalChanges = await this.calculateDelta(baseSnapshotId, changes);
    await this.applyChanges(incrementalChanges);
    
    return newSnapshotId;
  }
}
```

## 4.2 缓存策略设计

### 4.2.1 多层缓存架构

```typescript
// 缓存管理系统
export class CacheManager {
  private l1Cache: Map<string, any> = new Map(); // 内存缓存
  private l2Cache: LRUCache<string, any>; // LRU缓存
  private l3Cache: AsyncLRUCache<string, any>; // 持久化缓存
  
  constructor() {
    this.l2Cache = new LRUCache({ max: 1000, ttl: 1000 * 60 * 15 }); // 15分钟
    this.l3Cache = new AsyncLRUCache({
      max: 10000,
      ttl: 1000 * 60 * 60 * 24, // 24小时
      storage: new LevelDBAdapter(path.join('.zcu', 'cache'))
    });
  }
  
  // 智能缓存获取
  async get<T>(key: string, factory?: () => Promise<T>): Promise<T | undefined> {
    // L1缓存 - 内存
    if (this.l1Cache.has(key)) {
      return this.l1Cache.get(key);
    }
    
    // L2缓存 - LRU
    const l2Value = this.l2Cache.get(key);
    if (l2Value !== undefined) {
      this.l1Cache.set(key, l2Value);
      return l2Value;
    }
    
    // L3缓存 - 持久化
    const l3Value = await this.l3Cache.get(key);
    if (l3Value !== undefined) {
      this.l2Cache.set(key, l3Value);
      this.l1Cache.set(key, l3Value);
      return l3Value;
    }
    
    // 缓存未命中，使用工厂方法
    if (factory) {
      const value = await factory();
      await this.set(key, value);
      return value;
    }
    
    return undefined;
  }
  
  // 缓存写入
  async set<T>(key: string, value: T): Promise<void> {
    this.l1Cache.set(key, value);
    this.l2Cache.set(key, value);
    await this.l3Cache.set(key, value);
  }
  
  // 缓存失效策略
  async invalidate(pattern: string): Promise<void> {
    const regex = new RegExp(pattern);
    
    // 清理L1缓存
    for (const [key] of this.l1Cache) {
      if (regex.test(key)) {
        this.l1Cache.delete(key);
      }
    }
    
    // 清理L2缓存
    this.l2Cache.clear();
    
    // 清理L3缓存
    await this.l3Cache.clear();
  }
}

// 缓存预热策略
export class CacheWarmupStrategy {
  async warmupWorkspaceCache(workspaceId: string): Promise<void> {
    // 预加载工作空间元数据
    await cacheManager.get(`workspace:${workspaceId}`, 
      () => workspaceManager.getWorkspace(workspaceId)
    );
    
    // 预加载最近操作
    await cacheManager.get(`operations:${workspaceId}:recent`,
      () => operationManager.getRecentOperations(workspaceId, 10)
    );
    
    // 预加载热门快照
    await cacheManager.get(`snapshots:${workspaceId}:hot`,
      () => snapshotManager.getHotSnapshots(workspaceId)
    );
  }
}
```

---
