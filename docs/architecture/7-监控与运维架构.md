# 7. 监控与运维架构

## 7.1 监控系统设计

### 7.1.1 性能监控

```typescript
// 性能监控系统
export class PerformanceMonitor {
  private metrics: Map<string, MetricCollector> = new Map();
  private alerts: AlertManager;
  
  constructor() {
    this.alerts = new AlertManager();
    this.initializeMetricCollectors();
  }
  
  // 操作性能监控
  async monitorOperation<T>(
    operationName: string,
    operation: () => Promise<T>
  ): Promise<T> {
    const startTime = performance.now();
    const memoryBefore = process.memoryUsage();
    
    try {
      const result = await operation();
      const duration = performance.now() - startTime;
      const memoryAfter = process.memoryUsage();
      
      await this.recordMetric({
        name: operationName,
        duration,
        memoryDelta: memoryAfter.heapUsed - memoryBefore.heapUsed,
        success: true,
        timestamp: Date.now()
      });
      
      // 性能警告检查
      if (duration > this.getThreshold(operationName)) {
        await this.alerts.triggerAlert({
          type: 'performance_warning',
          operation: operationName,
          duration,
          threshold: this.getThreshold(operationName)
        });
      }
      
      return result;
      
    } catch (error) {
      await this.recordMetric({
        name: operationName,
        duration: performance.now() - startTime,
        error: error.message,
        success: false,
        timestamp: Date.now()
      });
      
      throw error;
    }
  }
  
  // 系统资源监控
  async collectSystemMetrics(): Promise<SystemMetrics> {
    const cpuUsage = await this.getCPUUsage();
    const memoryUsage = process.memoryUsage();
    const diskUsage = await this.getDiskUsage();
    
    const metrics: SystemMetrics = {
      cpu: {
        usage: cpuUsage,
        loadAverage: os.loadavg()
      },
      memory: {
        used: memoryUsage.heapUsed,
        total: memoryUsage.heapTotal,
        external: memoryUsage.external,
        rss: memoryUsage.rss
      },
      disk: diskUsage,
      timestamp: Date.now()
    };
    
    // 资源警告检查
    await this.checkResourceAlerts(metrics);
    
    return metrics;
  }
  
  // 业务指标监控
  async trackBusinessMetrics(): Promise<BusinessMetrics> {
    const db = await this.getDatabase();
    
    const metrics: BusinessMetrics = {
      // 操作统计
      operations: {
        undoCount: await db.count('operation:*:undo'),
        redoCount: await db.count('operation:*:redo'),
        snapshotCount: await db.count('snapshot:*'),
        conflictCount: await db.count('conflict:*:active')
      },
      
      // 工作空间统计
      workspaces: {
        activeCount: await db.count('workspace:*:active'),
        totalCount: await db.count('workspace:*'),
        conflictWorkspaces: await db.count('workspace:*:conflict')
      },
      
      // 性能统计
      performance: {
        averageUndoTime: await this.calculateAverageMetric('undo_operation'),
        averageSnapshotSize: await this.calculateAverageMetric('snapshot_size'),
        cacheHitRate: await this.calculateCacheHitRate()
      },
      
      timestamp: Date.now()
    };
    
    return metrics;
  }
}

// 告警管理系统
export class AlertManager {
  private alertHandlers: Map<string, AlertHandler[]> = new Map();
  private alertHistory: Alert[] = [];
  
  // 注册告警处理器
  registerHandler(alertType: string, handler: AlertHandler): void {
    if (!this.alertHandlers.has(alertType)) {
      this.alertHandlers.set(alertType, []);
    }
    
    this.alertHandlers.get(alertType)!.push(handler);
  }
  
  // 触发告警
  async triggerAlert(alert: Alert): Promise<void> {
    // 告警去重
    if (this.isDuplicateAlert(alert)) {
      return;
    }
    
    this.alertHistory.push(alert);
    
    const handlers = this.alertHandlers.get(alert.type) || [];
    
    await Promise.all(handlers.map(handler => 
      this.safeExecuteHandler(handler, alert)
    ));
  }
  
  private async safeExecuteHandler(handler: AlertHandler, alert: Alert): Promise<void> {
    try {
      await handler.handle(alert);
    } catch (error) {
      console.error(`Alert handler failed for ${alert.type}:`, error);
    }
  }
  
  private isDuplicateAlert(alert: Alert): boolean {
    const recentAlerts = this.alertHistory.filter(
      a => a.type === alert.type && Date.now() - a.timestamp < 300000 // 5分钟
    );
    
    return recentAlerts.length > 0;
  }
}
```

### 7.1.2 日志系统

```typescript
// 结构化日志系统
export class StructuredLogger {
  private logLevel: LogLevel = 'info';
  private logStream: WriteStream;
  
  constructor(config: LoggerConfig) {
    this.logLevel = config.level || 'info';
    this.logStream = fs.createWriteStream(config.logFile, { flags: 'a' });
  }
  
  // 结构化日志记录
  async log(level: LogLevel, message: string, context?: LogContext): Promise<void> {
    if (!this.shouldLog(level)) return;
    
    const logEntry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: this.sanitizeContext(context),
      traceId: context?.traceId || generateTraceId(),
      service: 'zcu-core'
    };
    
    const logLine = JSON.stringify(logEntry) + '\n';
    
    // 异步写入
    this.logStream.write(logLine);
    
    // 同时输出到控制台（开发模式）
    if (process.env.NODE_ENV === 'development') {
      this.consoleLog(logEntry);
    }
  }
  
  // 操作审计日志
  async auditLog(operation: Operation, result: OperationResult): Promise<void> {
    const auditEntry: AuditLogEntry = {
      timestamp: new Date().toISOString(),
      operationType: operation.type,
      operationId: operation.id,
      workspaceId: operation.workspaceId,
      userId: operation.userId || 'system',
      success: result.success,
      duration: result.duration,
      filesAffected: operation.files?.length || 0,
      errorMessage: result.error?.message,
      metadata: {
        userAgent: operation.userAgent,
        source: operation.source,
        autoGenerated: operation.autoGenerated
      }
    };
    
    // 写入审计日志文件
    const auditLogPath = path.join('.zcu', 'logs', 'audit.log');
    await fs.appendFile(auditLogPath, JSON.stringify(auditEntry) + '\n');
  }
  
  // 错误追踪
  async errorLog(error: Error, context: ErrorContext): Promise<void> {
    const errorEntry: ErrorLogEntry = {
      timestamp: new Date().toISOString(),
      level: 'error',
      message: error.message,
      stack: error.stack,
      context: this.sanitizeContext(context),
      errorType: error.constructor.name,
      traceId: context.traceId || generateTraceId()
    };
    
    await this.log('error', error.message, context);
    
    // 严重错误发送告警
    if (context.severity === 'critical') {
      await this.sendErrorAlert(errorEntry);
    }
  }
  
  private sanitizeContext(context?: any): any {
    if (!context) return {};
    
    const sanitizer = new DataSanitizer();
    return sanitizer.sanitizeData(context);
  }
}

// 日志轮转管理
export class LogRotationManager {
  private rotationConfig: LogRotationConfig;
  
  constructor(config: LogRotationConfig) {
    this.rotationConfig = config;
    this.scheduleRotation();
  }
  
  // 日志轮转
  async rotateLog(logFile: string): Promise<void> {
    const stats = await fs.stat(logFile);
    
    // 检查是否需要轮转
    if (stats.size < this.rotationConfig.maxSize && 
        Date.now() - stats.mtime.getTime() < this.rotationConfig.maxAge) {
      return;
    }
    
    const timestamp = new Date().toISOString().replace(/:/g, '-');
    const rotatedFile = `${logFile}.${timestamp}`;
    
    // 重命名当前日志文件
    await fs.rename(logFile, rotatedFile);
    
    // 创建新的日志文件
    await fs.writeFile(logFile, '');
    
    // 压缩旧文件
    if (this.rotationConfig.compress) {
      await this.compressLogFile(rotatedFile);
    }
    
    // 清理过期文件
    await this.cleanupOldLogs(path.dirname(logFile));
  }
  
  private async compressLogFile(logFile: string): Promise<void> {
    const gzip = zlib.createGzip();
    const source = fs.createReadStream(logFile);
    const destination = fs.createWriteStream(`${logFile}.gz`);
    
    return new Promise((resolve, reject) => {
      source.pipe(gzip).pipe(destination)
        .on('finish', async () => {
          await fs.unlink(logFile); // 删除原文件
          resolve();
        })
        .on('error', reject);
    });
  }
}
```

## 7.2 错误恢复机制

### 7.2.1 自动故障恢复

```typescript
// 故障恢复系统
export class FailureRecoverySystem {
  private recoveryStrategies: Map<string, RecoveryStrategy> = new Map();
  private recoveryHistory: RecoveryAttempt[] = [];
  
  constructor() {
    this.initializeRecoveryStrategies();
  }
  
  // 自动恢复处理
  async handleFailure(error: SystemError, context: FailureContext): Promise<RecoveryResult> {
    const strategy = this.selectRecoveryStrategy(error, context);
    
    if (!strategy) {
      return {
        success: false,
        reason: 'No suitable recovery strategy found',
        recommendation: 'Manual intervention required'
      };
    }
    
    const attempt: RecoveryAttempt = {
      id: generateId(),
      errorType: error.type,
      strategy: strategy.name,
      timestamp: Date.now(),
      context
    };
    
    try {
      const result = await strategy.recover(error, context);
      
      attempt.success = result.success;
      attempt.duration = Date.now() - attempt.timestamp;
      
      this.recoveryHistory.push(attempt);
      
      if (result.success) {
        await this.logRecoverySuccess(attempt, result);
      } else {
        await this.logRecoveryFailure(attempt, result);
      }
      
      return result;
      
    } catch (recoveryError) {
      attempt.success = false;
      attempt.error = recoveryError.message;
      attempt.duration = Date.now() - attempt.timestamp;
      
      this.recoveryHistory.push(attempt);
      
      return {
        success: false,
        reason: 'Recovery strategy failed',
        error: recoveryError,
        recommendation: 'Escalate to manual recovery'
      };
    }
  }
  
  private initializeRecoveryStrategies(): void {
    // 数据库连接失败恢复
    this.recoveryStrategies.set('database_connection_failed', {
      name: 'database_reconnect',
      recover: async (error, context) => {
        // 重新初始化数据库连接
        await this.reinitializeDatabase();
        
        // 验证连接
        const isHealthy = await this.verifyDatabaseHealth();
        
        return {
          success: isHealthy,
          reason: isHealthy ? 'Database reconnected successfully' : 'Database still unhealthy',
          actions: ['database_reconnected']
        };
      }
    });
    
    // 文件系统错误恢复
    this.recoveryStrategies.set('file_system_error', {
      name: 'file_system_recovery',
      recover: async (error, context) => {
        const actions: string[] = [];
        
        // 检查磁盘空间
        const diskSpace = await this.checkDiskSpace();
        if (diskSpace.available < 100 * 1024 * 1024) { // 100MB
          await this.cleanupTempFiles();
          actions.push('temp_files_cleaned');
        }
        
        // 修复文件权限
        if (error.message.includes('permission')) {
          await this.fixFilePermissions(context.projectPath);
          actions.push('permissions_fixed');
        }
        
        // 创建缺失目录
        if (error.message.includes('ENOENT')) {
          await fs.ensureDir(path.dirname(context.filePath));
          actions.push('directories_created');
        }
        
        return {
          success: actions.length > 0,
          reason: actions.length > 0 ? 'File system issues resolved' : 'No recovery actions needed',
          actions
        };
      }
    });
    
    // 内存不足恢复
    this.recoveryStrategies.set('out_of_memory', {
      name: 'memory_recovery',
      recover: async (error, context) => {
        const actions: string[] = [];
        
        // 清理缓存
        await cacheManager.clear();
        actions.push('cache_cleared');
        
        // 强制垃圾回收
        if (global.gc) {
          global.gc();
          actions.push('garbage_collected');
        }
        
        // 降级操作模式
        this.enableLowMemoryMode();
        actions.push('low_memory_mode_enabled');
        
        return {
          success: true,
          reason: 'Memory pressure reduced',
          actions,
          recommendation: 'Consider upgrading system memory'
        };
      }
    });
  }
  
  // 健康检查
  async performHealthCheck(): Promise<HealthCheckResult> {
    const checks: HealthCheck[] = [
      {
        name: 'database_health',
        check: async () => {
          const db = await this.getDatabase();
          await db.get('health_check');
          return { healthy: true };
        }
      },
      {
        name: 'file_system_health', 
        check: async () => {
          const testFile = path.join('.zcu', 'health_check.tmp');
          await fs.writeFile(testFile, 'health_check');
          await fs.unlink(testFile);
          return { healthy: true };
        }
      },
      {
        name: 'memory_health',
        check: async () => {
          const memoryUsage = process.memoryUsage();
          const isHealthy = memoryUsage.heapUsed < memoryUsage.heapTotal * 0.9;
          return { 
            healthy: isHealthy,
            details: { memoryUsage: memoryUsage.heapUsed / 1024 / 1024 }
          };
        }
      }
    ];
    
    const results = await Promise.all(
      checks.map(async (check) => {
        try {
          const result = await check.check();
          return { name: check.name, ...result };
        } catch (error) {
          return { 
            name: check.name, 
            healthy: false, 
            error: error.message 
          };
        }
      })
    );
    
    const overallHealth = results.every(r => r.healthy);
    
    return {
      healthy: overallHealth,
      checks: results,
      timestamp: Date.now()
    };
  }
}
```

---
