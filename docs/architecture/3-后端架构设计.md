# 3. 后端架构设计

## 3.1 核心API架构

### 3.1.1 微服务架构设计

```typescript
// 核心API服务架构
interface ZCUCoreService {
  // Undo/Redo引擎
  undoEngine: UndoRedoEngine;
  // AI工作空间管理
  workspaceManager: WorkspaceManager;
  // 冲突解决引擎
  conflictResolver: ConflictResolver;
  // 快照管理器
  snapshotManager: SnapshotManager;
  // Hook事件处理
  hookProcessor: HookEventProcessor;
}

// Express服务器配置
export const createZCUServer = (config: ZCUConfig) => {
  const app = express();
  
  // 中间件配置
  app.use(cors());
  app.use(express.json({ limit: '100mb' }));
  app.use(compression());
  
  // API路由
  app.use('/api/snapshots', snapshotRoutes);
  app.use('/api/workspaces', workspaceRoutes);
  app.use('/api/conflicts', conflictRoutes);
  app.use('/api/operations', operationRoutes);
  
  // WebSocket支持
  const server = http.createServer(app);
  const io = new Server(server, {
    cors: { origin: "*" }
  });
  
  // 实时通信
  io.on('connection', (socket) => {
    socket.on('workspace:subscribe', handleWorkspaceSubscription);
    socket.on('conflict:subscribe', handleConflictSubscription);
  });
  
  return { app, server, io };
};
```

### 3.1.2 RESTful API设计

```typescript
// API端点定义
export const apiEndpoints = {
  // 快照管理
  snapshots: {
    list: 'GET /api/snapshots',
    create: 'POST /api/snapshots',
    get: 'GET /api/snapshots/:id',
    restore: 'POST /api/snapshots/:id/restore',
    delete: 'DELETE /api/snapshots/:id'
  },
  
  // 工作空间管理
  workspaces: {
    list: 'GET /api/workspaces',
    get: 'GET /api/workspaces/:id',
    pause: 'POST /api/workspaces/:id/pause',
    resume: 'POST /api/workspaces/:id/resume',
    status: 'GET /api/workspaces/:id/status'
  },
  
  // 冲突管理
  conflicts: {
    list: 'GET /api/conflicts',
    get: 'GET /api/conflicts/:id',
    resolve: 'POST /api/conflicts/:id/resolve',
    preview: 'GET /api/conflicts/:id/preview'
  },
  
  // 操作管理
  operations: {
    history: 'GET /api/operations/history',
    undo: 'POST /api/operations/undo',
    redo: 'POST /api/operations/redo',
    batch: 'POST /api/operations/batch'
  }
} as const;

// 类型安全的API客户端
export class ZCUApiClient {
  constructor(private baseURL: string) {}
  
  async createSnapshot(description: string): Promise<Snapshot> {
    const response = await fetch(`${this.baseURL}/api/snapshots`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ description })
    });
    return response.json();
  }
  
  async getWorkspaces(): Promise<Workspace[]> {
    const response = await fetch(`${this.baseURL}/api/workspaces`);
    return response.json();
  }
  
  async resolveConflict(id: string, resolution: ConflictResolution): Promise<void> {
    await fetch(`${this.baseURL}/api/conflicts/${id}/resolve`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(resolution)
    });
  }
}
```

## 3.2 AI工作空间隔离机制

### 3.2.1 核心隔离算法

```typescript
// AI工作空间隔离引擎
export class WorkspaceIsolationEngine {
  private workspaces = new Map<string, AIWorkspace>();
  private fileLocks = new Map<string, WorkspaceLock>();
  
  // 创建或获取工作空间
  async getOrCreateWorkspace(sessionId: string, aiAgent: string, projectPath: string): Promise<AIWorkspace> {
    const workspaceId = this.generateWorkspaceId(sessionId, aiAgent);
    
    if (this.workspaces.has(workspaceId)) {
      return this.workspaces.get(workspaceId)!;
    }
    
    const workspace: AIWorkspace = {
      id: workspaceId,
      sessionId,
      aiAgent,
      projectPath,
      state: 'active',
      operationChain: [],
      createdAt: Date.now(),
      lastActivity: Date.now()
    };
    
    this.workspaces.set(workspaceId, workspace);
    await this.persistWorkspace(workspace);
    
    return workspace;
  }
  
  // 预防性冲突检测
  async checkConflicts(workspaceId: string, files: string[]): Promise<ConflictInfo[]> {
    const conflicts: ConflictInfo[] = [];
    
    for (const filePath of files) {
      const existingLock = this.fileLocks.get(filePath);
      
      if (existingLock && existingLock.workspaceId !== workspaceId) {
        // 检测到文件锁冲突
        conflicts.push({
          id: generateId(),
          filePath,
          sourceWorkspace: workspaceId,
          conflictWorkspace: existingLock.workspaceId,
          type: 'file_lock_conflict',
          timestamp: Date.now()
        });
      }
    }
    
    return conflicts;
  }
  
  // 文件锁管理
  async acquireFileLocks(workspaceId: string, files: string[]): Promise<boolean> {
    const conflicts = await this.checkConflicts(workspaceId, files);
    
    if (conflicts.length > 0) {
      // 通知冲突给相关工作空间
      await this.notifyConflicts(conflicts);
      return false;
    }
    
    // 获取文件锁
    for (const filePath of files) {
      this.fileLocks.set(filePath, {
        workspaceId,
        filePath,
        acquiredAt: Date.now()
      });
    }
    
    return true;
  }
  
  // 释放文件锁
  async releaseFileLocks(workspaceId: string, files: string[]): Promise<void> {
    for (const filePath of files) {
      const lock = this.fileLocks.get(filePath);
      if (lock && lock.workspaceId === workspaceId) {
        this.fileLocks.delete(filePath);
      }
    }
  }
}
```

### 3.2.2 冲突检测与解决

```typescript
// 智能冲突检测系统
export class ConflictDetectionSystem {
  private detectionStrategies: ConflictDetectionStrategy[] = [
    new FileContentConflictDetector(),
    new TimestampConflictDetector(), 
    new SemanticConflictDetector(),
    new DependencyConflictDetector()
  ];
  
  async detectConflicts(operation: FileOperation): Promise<ConflictInfo[]> {
    const allConflicts: ConflictInfo[] = [];
    
    for (const strategy of this.detectionStrategies) {
      const conflicts = await strategy.detect(operation);
      allConflicts.push(...conflicts);
    }
    
    // 去重和优先级排序
    return this.deduplicateAndPrioritize(allConflicts);
  }
  
  // 文件内容冲突检测器
  private class FileContentConflictDetector implements ConflictDetectionStrategy {
    async detect(operation: FileOperation): Promise<ConflictInfo[]> {
      const conflicts: ConflictInfo[] = [];
      
      for (const file of operation.files) {
        // 检查是否有其他工作空间同时修改了相同文件
        const concurrentOperations = await this.getConcurrentOperations(
          file.path, 
          operation.workspaceId,
          operation.timestamp
        );
        
        for (const concurrent of concurrentOperations) {
          const conflict = await this.analyzeContentConflict(
            file,
            concurrent,
            operation
          );
          
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
      
      return conflicts;
    }
  }
  
  // 语义冲突检测器
  private class SemanticConflictDetector implements ConflictDetectionStrategy {
    async detect(operation: FileOperation): Promise<ConflictInfo[]> {
      // 基于AST分析的语义冲突检测
      // 检测函数重命名、导入依赖变化等语义级冲突
      const conflicts: ConflictInfo[] = [];
      
      for (const file of operation.files) {
        if (this.isCodeFile(file.path)) {
          const semanticConflicts = await this.analyzeSemanticChanges(file);
          conflicts.push(...semanticConflicts);
        }
      }
      
      return conflicts;
    }
  }
}
```

---
