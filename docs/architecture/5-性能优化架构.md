# 5. 性能优化架构

## 5.1 前端性能优化

### 5.1.1 虚拟滚动和懒加载

```typescript
// 虚拟滚动优化
export class VirtualScrollOptimizer {
  private visibleRange = { start: 0, end: 0 };
  private itemHeight = 60;
  private bufferSize = 5;
  
  calculateVisibleRange(scrollTop: number, containerHeight: number, totalItems: number) {
    const start = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.bufferSize);
    const end = Math.min(
      totalItems,
      start + Math.ceil(containerHeight / this.itemHeight) + this.bufferSize * 2
    );
    
    return { start, end };
  }
  
  shouldUpdate(newRange: { start: number, end: number }): boolean {
    return newRange.start !== this.visibleRange.start || 
           newRange.end !== this.visibleRange.end;
  }
}

// React虚拟滚动Hook
export const useVirtualScroll = <T>(
  items: T[],
  containerHeight: number,
  itemHeight: number = 60
) => {
  const [scrollTop, setScrollTop] = useState(0);
  const optimizer = useMemo(() => new VirtualScrollOptimizer(), []);
  
  const visibleRange = useMemo(() => {
    return optimizer.calculateVisibleRange(scrollTop, containerHeight, items.length);
  }, [scrollTop, containerHeight, items.length, optimizer]);
  
  const visibleItems = useMemo(() => {
    return items.slice(visibleRange.start, visibleRange.end).map((item, index) => ({
      item,
      index: visibleRange.start + index,
      top: (visibleRange.start + index) * itemHeight
    }));
  }, [items, visibleRange, itemHeight]);
  
  return {
    visibleItems,
    totalHeight: items.length * itemHeight,
    scrollTop,
    setScrollTop,
    visibleRange
  };
};
```

### 5.1.2 状态管理优化

```typescript
// Zustand状态管理优化
import { subscribeWithSelector } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

export const useZCUStore = create<ZCUState>()(
  subscribeWithSelector(
    immer((set, get) => ({
      // 状态分片
      snapshots: {
        items: [],
        loading: false,
        error: null,
        pagination: { page: 1, size: 50, total: 0 }
      },
      
      workspaces: {
        active: [],
        inactive: [],
        conflicts: []
      },
      
      ui: {
        theme: 'light',
        sidebarOpen: true,
        currentView: 'snapshots',
        notifications: []
      },
      
      // 优化的Actions
      actions: {
        // 批量状态更新
        batchUpdate: (updates: Partial<ZCUState>) => {
          set((state) => {
            Object.assign(state, updates);
          });
        },
        
        // 智能缓存更新
        updateSnapshots: (snapshots: Snapshot[]) => {
          set((state) => {
            state.snapshots.items = snapshots;
            state.snapshots.loading = false;
          });
          
          // 更新缓存
          cacheManager.set('snapshots:recent', snapshots);
        },
        
        // 增量状态更新
        updateWorkspaceStatus: (workspaceId: string, status: WorkspaceStatus) => {
          set((state) => {
            const workspace = state.workspaces.active.find(w => w.id === workspaceId);
            if (workspace) {
              workspace.status = status;
            }
          });
        }
      }
    }))
  )
);

// 选择器优化
export const selectSnapshots = (state: ZCUState) => state.snapshots.items;
export const selectActiveWorkspaces = (state: ZCUState) => state.workspaces.active;
export const selectUIState = (state: ZCUState) => state.ui;

// 订阅优化
export const useSnapshotSubscription = () => {
  const snapshots = useZCUStore(selectSnapshots);
  const [localSnapshots, setLocalSnapshots] = useState(snapshots);
  
  // 防抖更新
  const debouncedUpdate = useMemo(
    () => debounce(setLocalSnapshots, 100),
    []
  );
  
  useEffect(() => {
    debouncedUpdate(snapshots);
  }, [snapshots, debouncedUpdate]);
  
  return localSnapshots;
};
```

## 5.2 后端性能优化

### 5.2.1 数据库查询优化

```typescript
// LevelDB查询优化
export class OptimizedLevelDBClient {
  private db: Level;
  private batchQueue: BatchOperation[] = [];
  private batchTimeout: NodeJS.Timeout | null = null;
  
  constructor(dbPath: string) {
    this.db = new Level(dbPath, { 
      valueEncoding: 'json',
      cacheSize: 32 * 1024 * 1024 // 32MB缓存
    });
  }
  
  // 批量操作优化
  async batchPut(key: string, value: any): Promise<void> {
    this.batchQueue.push({ type: 'put', key, value });
    
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
    }
    
    // 批量提交延迟
    this.batchTimeout = setTimeout(() => {
      this.flushBatch();
    }, 10); // 10ms内的操作合并
  }
  
  private async flushBatch(): Promise<void> {
    if (this.batchQueue.length === 0) return;
    
    const batch = this.db.batch();
    
    for (const operation of this.batchQueue) {
      switch (operation.type) {
        case 'put':
          batch.put(operation.key, operation.value);
          break;
        case 'del':
          batch.del(operation.key);
          break;
      }
    }
    
    await batch.write();
    this.batchQueue = [];
    this.batchTimeout = null;
  }
  
  // 范围查询优化
  async getByPrefix(prefix: string, limit = 100): Promise<Array<{key: string, value: any}>> {
    const results: Array<{key: string, value: any}> = [];
    
    const iterator = this.db.iterator({
      gte: prefix,
      lt: prefix + '\xFF',
      limit
    });
    
    for await (const [key, value] of iterator) {
      results.push({ key, value });
    }
    
    return results;
  }
  
  // 并发查询优化
  async parallelGet(keys: string[]): Promise<Map<string, any>> {
    const results = new Map();
    const chunks = this.chunkArray(keys, 50); // 分批查询
    
    const promises = chunks.map(async (chunk) => {
      const chunkResults = await Promise.allSettled(
        chunk.map(key => this.db.get(key))
      );
      
      chunk.forEach((key, index) => {
        const result = chunkResults[index];
        if (result.status === 'fulfilled') {
          results.set(key, result.value);
        }
      });
    });
    
    await Promise.all(promises);
    return results;
  }
}
```

### 5.2.2 文件操作优化

```typescript
// 文件操作优化器
export class FileOperationOptimizer {
  private operationQueue: FileOperation[] = [];
  private processing = false;
  
  // 智能文件差异计算
  async calculateOptimizedDiff(
    baseSnapshot: string,
    targetSnapshot: string
  ): Promise<OptimizedDiff> {
    // 使用二进制差异算法
    const baseBinary = await this.readFileBinary(baseSnapshot);
    const targetBinary = await this.readFileBinary(targetSnapshot);
    
    // Myers算法优化的差异计算
    const diff = await this.myersDiff(baseBinary, targetBinary);
    
    // 压缩差异数据
    const compressedDiff = await this.compressDiff(diff);
    
    return {
      type: 'optimized',
      baseSnapshot,
      targetSnapshot,
      diff: compressedDiff,
      compressionRatio: baseBinary.length / compressedDiff.length
    };
  }
  
  // 并行文件处理
  async processFilesInParallel<T>(
    files: string[],
    processor: (file: string) => Promise<T>,
    concurrency = 10
  ): Promise<T[]> {
    const results: T[] = [];
    const chunks = this.chunkArray(files, concurrency);
    
    for (const chunk of chunks) {
      const chunkResults = await Promise.all(
        chunk.map(file => processor(file))
      );
      results.push(...chunkResults);
    }
    
    return results;
  }
  
  // 增量同步优化
  async incrementalSync(
    sourceDir: string,
    targetDir: string,
    lastSyncTimestamp: number
  ): Promise<SyncResult> {
    // 只同步变更的文件
    const changedFiles = await this.getChangedFiles(sourceDir, lastSyncTimestamp);
    
    const syncOperations = await Promise.all(
      changedFiles.map(async (file) => {
        const sourcePath = path.join(sourceDir, file.path);
        const targetPath = path.join(targetDir, file.path);
        
        switch (file.operation) {
          case 'create':
          case 'modify':
            await fs.copy(sourcePath, targetPath);
            break;
          case 'delete':
            await fs.remove(targetPath);
            break;
          case 'rename':
            await fs.move(
              path.join(targetDir, file.oldPath),
              targetPath
            );
            break;
        }
        
        return { file: file.path, operation: file.operation };
      })
    );
    
    return {
      syncedFiles: syncOperations.length,
      operations: syncOperations,
      duration: Date.now() - performance.now()
    };
  }
}
```

---
